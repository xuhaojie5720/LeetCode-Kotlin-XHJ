# 4Sum（四数之和）—Kotlin 学习样本

本页并列展示 Java 与 Kotlin 的等价实现，逻辑与复杂度保持一致，便于迁移参考。

## 原始 Java 代码

```java
import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ret = new ArrayList<>();
        int n = nums.length;
        Arrays.sort(nums);

        for (int d = n - 1; d >= 3;) {
            for (int c = d - 1; c >= 2;) {
                int a = 0;
                int b = c - 1;

                while (a < b) {
                    long sum = (long) nums[a] + nums[b] + nums[c] + nums[d];
                    if (sum == target) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[a]);
                        list.add(nums[b]);
                        list.add(nums[c]);
                        list.add(nums[d]);
                        ret.add(list);

                        int i = a;
                        while (i < b && nums[i] == nums[a]) { i++; }
                        a = i;

                        int j = b;
                        while (j > a && nums[j] == nums[b]) { j--; }
                        b = j;
                    } else if (sum < target) {
                        int i = a;
                        while (i < b && nums[i] == nums[a]) { i++; }
                        a = i;
                    } else { // sum > target
                        int j = b;
                        while (j > a && nums[j] == nums[b]) { j--; }
                        b = j;
                    }
                }

                int i = c;
                while (i >= 2 && nums[i] == nums[c]) { i--; }
                c = i;
            }
            int i = d;
            while (i >= 3 && nums[i] == nums[d]) { i--; }
            d = i;
        }

        return ret;
    }
}
```

## 等价 Kotlin 代码（逻辑不变）

```kotlin
class Solution {
    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {
        val res = mutableListOf<List<Int>>() // Kotlin：可变列表存放结果
        val n = nums.size
        nums.sort() // Kotlin：IntArray 原地排序

        var d = n - 1
        while (d >= 3) {
            var c = d - 1
            while (c >= 2) {
                var a = 0
                var b = c - 1
                while (a < b) {
                    val sum = nums[a].toLong() + nums[b].toLong() + nums[c].toLong() + nums[d].toLong() // Kotlin：Long 防溢出
                    when {
                        sum == target.toLong() -> {
                            res.add(listOf(nums[a], nums[b], nums[c], nums[d])) // Kotlin：只读四元组

                            var i = a
                            while (i < b && nums[i] == nums[a]) i++ // 去重 a
                            a = i

                            var j = b
                            while (j > a && nums[j] == nums[b]) j-- // 去重 b
                            b = j
                        }
                        sum < target -> {
                            var i = a
                            while (i < b && nums[i] == nums[a]) i++ // 去重并右移 a
                            a = i
                        }
                        else -> { // sum > target
                            var j = b
                            while (j > a && nums[j] == nums[b]) j-- // 去重并左移 b
                            b = j
                        }
                    }
                }

                var i = c
                while (i >= 2 && nums[i] == nums[c]) i-- // 去重 c
                c = i
            }

            var i = d
            while (i >= 3 && nums[i] == nums[d]) i-- // 去重 d
            d = i
        }

        return res
    }
}
```

## Kotlin 要点对照

- 整型溢出：四数求和使用 `toLong()`，与 Java 显式强转到 `long` 一致。
- 原地排序：`IntArray.sort()`，空间 O(1)。
- 结果容器：`mutableListOf` 收集，子结果用只读 `listOf`。
- 指针与去重：与 Java 完全一致的 while 结构，时间 O(n^3)。

## 简单测试（Kotlin）

```kotlin
fun main() {
    val nums = intArrayOf(1,0,-1,0,-2,2)
    println(Solution().fourSum(nums, 0)) // [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
}
```
