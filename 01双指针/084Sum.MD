# 4Sum（四数之和）—Kotlin 学习样本

本页并列展示 Java 与 Kotlin 的等价实现，逻辑与复杂度保持一致，便于迁移参考。

## 原始 Java 代码

```java
import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ret = new ArrayList<>();
        int n = nums.length;
        Arrays.sort(nums);

        for (int d = n - 1; d >= 3;) {
            for (int c = d - 1; c >= 2;) {
                int a = 0;
                int b = c - 1;

                while (a < b) {
                    long sum = (long) nums[a] + nums[b] + nums[c] + nums[d];
                    if (sum == target) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[a]);
                        list.add(nums[b]);
                        list.add(nums[c]);
                        list.add(nums[d]);
                        ret.add(list);

                        int i = a;
                        while (i < b && nums[i] == nums[a]) { i++; }
                        a = i;

                        int j = b;
                        while (j > a && nums[j] == nums[b]) { j--; }
                        b = j;
                    } else if (sum < target) {
                        int i = a;
                        while (i < b && nums[i] == nums[a]) { i++; }
                        a = i;
                    } else { // sum > target
                        int j = b;
                        while (j > a && nums[j] == nums[b]) { j--; }
                        b = j;
                    }
                }

                int i = c;
                while (i >= 2 && nums[i] == nums[c]) { i--; }
                c = i;
            }
            int i = d;
            while (i >= 3 && nums[i] == nums[d]) { i--; }
            d = i;
        }

        return ret;
    }
}
```

## 等价 Kotlin 代码（逻辑不变）

```kotlin
class Solution {
    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {
        val res = mutableListOf<List<Int>>() // Kotlin：可变列表存放结果
        val n = nums.size
        nums.sort() // Kotlin：IntArray 原地排序

        var d = n - 1
        while (d >= 3) {
            var c = d - 1
            while (c >= 2) {
                var a = 0
                var b = c - 1
                while (a < b) {
                    val sum = nums[a].toLong() + nums[b].toLong() + nums[c].toLong() + nums[d].toLong() // Kotlin：Long 防溢出
                    when {
                        sum == target.toLong() -> {
                            res.add(listOf(nums[a], nums[b], nums[c], nums[d])) // Kotlin：只读四元组

                            var i = a
                            while (i < b && nums[i] == nums[a]) i++ // 去重 a
                            a = i

                            var j = b
                            while (j > a && nums[j] == nums[b]) j-- // 去重 b
                            b = j
                        }
                        sum < target -> {
                            var i = a
                            while (i < b && nums[i] == nums[a]) i++ // 去重并右移 a
                            a = i
                        }
                        else -> { // sum > target
                            var j = b
                            while (j > a && nums[j] == nums[b]) j-- // 去重并左移 b
                            b = j
                        }
                    }
                }

                var i = c
                while (i >= 2 && nums[i] == nums[c]) i-- // 去重 c
                c = i
            }

            var i = d
            while (i >= 3 && nums[i] == nums[d]) i-- // 去重 d
            d = i
        }

        return res
    }
}
```

## Kotlin 要点对照

- 整型溢出：四数求和使用 `toLong()`，与 Java 显式强转到 `long` 一致。
- 原地排序：`IntArray.sort()`，空间 O(1)。
- 结果容器：`mutableListOf` 收集，子结果用只读 `listOf`。
- 指针与去重：与 Java 完全一致的 while 结构，时间 O(n^3)。

## 简单测试（Kotlin）

```kotlin
fun main() {
    val nums = intArrayOf(1,0,-1,0,-2,2)
    println(Solution().fourSum(nums, 0)) // [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
}
```

## Kotlin 函数式风格（等价逻辑）

```kotlin
// 递归改写嵌套循环：外层 d/c 双层递减，内层双指针推进；保持 O(n^3)
class SolutionFp {
    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {
        nums.sort()
        val res = mutableListOf<List<Int>>()

        tailrec fun two(a: Int, b: Int, c: Int, d: Int) {
            if (a >= b) return
            val sum = nums[a].toLong() + nums[b].toLong() + nums[c].toLong() + nums[d].toLong()
            when {
                sum == target.toLong() -> {
                    res += listOf(nums[a], nums[b], nums[c], nums[d])
                    var i = a
                    while (i < b && nums[i] == nums[a]) i++
                    var j = b
                    while (j > i && nums[j] == nums[b]) j--
                    two(i, j, c, d)
                }
                sum < target -> {
                    var i = a
                    while (i < b && nums[i] == nums[a]) i++
                    two(i, b, c, d)
                }
                else -> {
                    var j = b
                    while (j > a && nums[j] == nums[b]) j--
                    two(a, j, c, d)
                }
            }
        }

        tailrec fun scanC(c: Int, d: Int) {
            if (c < 2) return
            two(0, c - 1, c, d)
            var i = c
            while (i >= 2 && nums[i] == nums[c]) i--
            scanC(i, d)
        }

        tailrec fun scanD(d: Int) {
            if (d < 3) return
            scanC(d - 1, d)
            var i = d
            while (i >= 3 && nums[i] == nums[d]) i--
            scanD(i)
        }

        scanD(nums.lastIndex)
        return res
    }
}
```

说明（FP 版）
- 思路不变：排序 + 固定两位 + 内层双指针 + 去重。
- 函数式要点：递归替代多层循环，避免显式 while 嵌套。
